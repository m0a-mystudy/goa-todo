// Code generated by goagen v1.2.0, DO NOT EDIT.
//
// API "Todo API": todo Resource Client
//
// Command:
// $ goagen
// --design=github.com/m0a-mystudy/goa-todo/design
// --out=$(GOPATH)/src/github.com/m0a-mystudy/goa-todo
// --version=v1.2.0-dirty

package client

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// CreateTodoPayload is the todo create action payload.
type CreateTodoPayload struct {
	Completed bool `form:"completed" json:"completed" xml:"completed"`
	// Date of creation
	Created time.Time `form:"created" json:"created" xml:"created"`
	// ID of Todo
	ID *int `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Date of last update
	Modified time.Time `form:"modified" json:"modified" xml:"modified"`
	Title    string    `form:"title" json:"title" xml:"title"`
}

// CreateTodoPath computes a request path to the create action of todo.
func CreateTodoPath() string {

	return fmt.Sprintf("/api/todos")
}

// Create new todo
func (c *Client) CreateTodo(ctx context.Context, path string, payload *CreateTodoPayload, contentType string) (*http.Response, error) {
	req, err := c.NewCreateTodoRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewCreateTodoRequest create the request corresponding to the create action endpoint of the todo resource.
func (c *Client) NewCreateTodoRequest(ctx context.Context, path string, payload *CreateTodoPayload, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}

// ListTodoPath computes a request path to the list action of todo.
func ListTodoPath() string {

	return fmt.Sprintf("/api/todos")
}

// Retrieve all todos.
func (c *Client) ListTodo(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewListTodoRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListTodoRequest create the request corresponding to the list action endpoint of the todo resource.
func (c *Client) NewListTodoRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ShowTodoPath computes a request path to the show action of todo.
func ShowTodoPath(todoID int) string {
	param0 := strconv.Itoa(todoID)

	return fmt.Sprintf("/api/todos/%s", param0)
}

// Retrieve todo within id.
func (c *Client) ShowTodo(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewShowTodoRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewShowTodoRequest create the request corresponding to the show action endpoint of the todo resource.
func (c *Client) NewShowTodoRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	return req, nil
}

// UpdateTodoPayload is the todo update action payload.
type UpdateTodoPayload struct {
	Completed *bool   `form:"completed,omitempty" json:"completed,omitempty" xml:"completed,omitempty"`
	Title     *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// UpdateTodoPath computes a request path to the update action of todo.
func UpdateTodoPath(todoID int) string {
	param0 := strconv.Itoa(todoID)

	return fmt.Sprintf("/api/todos/%s", param0)
}

// change todo
func (c *Client) UpdateTodo(ctx context.Context, path string, payload *UpdateTodoPayload, contentType string) (*http.Response, error) {
	req, err := c.NewUpdateTodoRequest(ctx, path, payload, contentType)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewUpdateTodoRequest create the request corresponding to the update action endpoint of the todo resource.
func (c *Client) NewUpdateTodoRequest(ctx context.Context, path string, payload *UpdateTodoPayload, contentType string) (*http.Request, error) {
	var body bytes.Buffer
	if contentType == "" {
		contentType = "*/*" // Use default encoder
	}
	err := c.Encoder.Encode(payload, &body, contentType)
	if err != nil {
		return nil, fmt.Errorf("failed to encode body: %s", err)
	}
	scheme := c.Scheme
	if scheme == "" {
		scheme = "http"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("PUT", u.String(), &body)
	if err != nil {
		return nil, err
	}
	header := req.Header
	if contentType == "*/*" {
		header.Set("Content-Type", "application/json")
	} else {
		header.Set("Content-Type", contentType)
	}
	return req, nil
}
